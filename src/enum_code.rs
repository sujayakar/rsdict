use std::cmp;
use super::constants::SMALL_BLOCK_SIZE;

mod binomial {
    // Load in the generated binomial coefficient table generated by `build.rs`.
    include!(concat!(env!("OUT_DIR"), "/binomial.rs"));
}

fn binomial_coefficient(n: u8, k: u8) -> u64 {
    use self::binomial::COEFFICIENT_TABLE;
    debug_assert!(n <= 64 && k <= 64);
    debug_assert!(k <= n);

    // See `build.rs` for an explanation of how the table is indexed.
    let (q, r) = (n as usize / 2, n as usize % 2);
    let row_start = (q + r) * (q + 1);
    let k = cmp::min(k, n - k) as usize;
    COEFFICIENT_TABLE[row_start + k]
}

pub fn encode(value: u64, class: u8) -> (u8, u64) {
    debug_assert_eq!(value.count_ones() as u8, class);
    let code_len = ENUM_CODE_LENGTH[class as usize];

    // Fast path: return the integer unchanged if we're using all of our bits.
    if code_len == SMALL_BLOCK_SIZE as u8 {
        return (code_len, value);
    }

    let mut code = 0u64;
    let mut k = class;
    for i in 0..(SMALL_BLOCK_SIZE as u8) {
        let n = SMALL_BLOCK_SIZE as u8 - i;
        if (value >> i) & 1 != 0 {
            if n > k {
                code += binomial_coefficient(n - 1, k);
            }
            k -= 1;
        }
    }
    (code_len, code)
}

#[cfg(test)]
pub fn decode(mut code: u64, class: u8) -> u64 {
    if ENUM_CODE_LENGTH[class as usize] == SMALL_BLOCK_SIZE as u8 {
        return code;
    }
    let mut value = 0u64;
    let mut k = class;
    for i in 0..(SMALL_BLOCK_SIZE as u8) {
        let n = SMALL_BLOCK_SIZE as u8 - i;
        if n > k {
            let zero_case_num = binomial_coefficient(n - 1, k);
            if code >= zero_case_num {
                value |= 1 << i;
                code -= zero_case_num;
                k -= 1;
            }
        }
        // If `n == k`, this bit must be set.
        else {
            value |= 1 << i;
            k -= 1;
        }
    }
    value
}

pub fn decode_bit(mut code: u64, class: u8, pos: u64) -> bool {
    if ENUM_CODE_LENGTH[class as usize] == SMALL_BLOCK_SIZE as u8 {
        return (code >> pos) & 1 != 0;
    }
    let mut k = class;
    for i in 0..(pos as u8) {
        let n = SMALL_BLOCK_SIZE as u8 - i;
        let zero_case_num = 
            if n > k {
                binomial_coefficient(n as u8 - 1, k as u8)
            } else {
                0
            };
        if code >= zero_case_num {
            code -= zero_case_num;
            k -= 1;
        }
    }
    let n = SMALL_BLOCK_SIZE  - pos;
    code >= 
        if n > k as u64 {
            binomial_coefficient(n as u8 - 1, k as u8)
        } else {
            0
        }
}

#[inline(always)]
fn rank_impl(mut code: u64, class: u8, pos: u64) -> u64 {
    if ENUM_CODE_LENGTH[class as usize] == SMALL_BLOCK_SIZE as u8 {
        return (code & ((1 << pos) - 1)).count_ones() as u64;
    }
    let mut cur_rank = class;
    for i in 0..pos {
        let n = SMALL_BLOCK_SIZE - i - 1;
        let zero_case_num = binomial_coefficient(n as u8, cur_rank);
        if code >= zero_case_num {
            code -= zero_case_num;
            cur_rank -= 1;
        }
    }
    (class - cur_rank) as u64
}

#[target_feature(enable = "popcnt")]
unsafe fn rank_with_popcount(code: u64, class: u8, pos: u64) -> u64 {
    rank_impl(code, class, pos)
}

pub fn rank(code: u64, class: u8, pos: u64) -> u64 {
    if is_x86_feature_detected!("popcnt") {
        unsafe { rank_with_popcount(code, class, pos) }
    } else {
        rank_impl(code, class, pos)
    }
}

// Adapted from https://lemire.me/blog/2018/02/21/iterating-over-set-bits-quickly/
pub fn select1_raw(mut code: u64, mut rank: u64) -> u64 {
    debug_assert!(rank < code.count_ones() as u64);
    for _ in 0..64 {
        let t = code & code.wrapping_neg();
        if rank == 0 {
            return code.trailing_zeros() as u64;
        }
        rank -= 1;
        code ^= t;
    }
    debug_assert!(false, "select1_raw past end of codeword");
    0
}

pub fn select1(mut code: u64, class: u8, mut rank: u64) -> u64 {
    if ENUM_CODE_LENGTH[class as usize] == SMALL_BLOCK_SIZE as u8 {
        return select1_raw(code, rank);
    }
    let mut k = class;
    for i in 0..SMALL_BLOCK_SIZE {
        let n = SMALL_BLOCK_SIZE - i;
        let zero_case_num = 
            if n > k as u64 {
                binomial_coefficient(n as u8 - 1, k as u8)
            } else {
                0
            };

        if code >= zero_case_num {
            if rank == 0 {
                return i;
            }
            rank -= 1;
            code -= zero_case_num;
            k -= 1;
        }
    }
    debug_assert!(false, "select1 past end of codeword");
    0
}

pub fn select0(mut code: u64, class: u8, mut rank: u64) -> u64 {
    if ENUM_CODE_LENGTH[class as usize] == SMALL_BLOCK_SIZE as u8 {
        return select1_raw(!code, rank);
    }
    let mut k = class as usize;
    for i in 0..SMALL_BLOCK_SIZE {
        let n = SMALL_BLOCK_SIZE - i - 1;
        let zero_case_num = binomial_coefficient(n as u8, k as u8);
        if code >= zero_case_num {
            code -= zero_case_num;
            k -= 1;
        } else {
            if rank == 0 {
                return i;
            }
            rank -= 1;
        }
    }
    debug_assert!(false, "select0 past end of codeword");
    0
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;
    use super::{binomial_coefficient, decode, decode_bit, encode, rank, select0, select1};
    use crate::test_helpers::hash_u64;
    use succinct::broadword;

    fn check_roundtrip(value: u64) -> bool {
        let class = value.count_ones() as u8;
        let (_, code) = encode(value, class);
        decode(code, class) == value
    }

    #[test]
    fn test_encode() {
        for i in 0..64 {
            check_roundtrip(std::u64::MAX << i);
        }
        check_roundtrip(0);
    }

    #[quickcheck]
    fn qc_decode(value: u64) -> bool {
        check_roundtrip(value)
    }

    #[quickcheck]
    fn qc_decode_hashed(value: u64) -> bool {
        check_roundtrip(hash_u64(value))
    }

    #[quickcheck]
    fn qc_decode_bit(value: u64) -> bool {
        let value = hash_u64(value);
        let class = value.count_ones() as u8;
        let (_, code) = encode(value, class);
        (0..64).all(|i| {
            let computed = decode_bit(code, class, i);
            let expected = (value >> i) & 1 != 0;
            computed == expected
        })
    }

    #[quickcheck]
    fn qc_rank(value: u64) -> bool {
        let value = hash_u64(value);
        let class = value.count_ones() as u8;
        let (_, code) = encode(value, class);
        (0..64).all(|i| {
            let computed = rank(code, class, i);
            let expected = (value & ((1 << i) - 1)).count_ones() as u64;
            computed == expected
        })
    }

    #[quickcheck]
    fn qc_select0(value: u64) -> bool {
        let value = hash_u64(value);
        let class = value.count_ones() as u8;
        let (_, code) = encode(value, class);
        (0..(64 - class) as u64).all(|i| {
            let computed = select0(code, class, i) as usize;
            let expected = broadword::select1_raw(i as usize, !value);
            computed == expected
        })
    }

    #[quickcheck]
    fn qc_select1(value: u64) -> bool {
        let value = hash_u64(value);
        let class = value.count_ones() as u8;
        let (_, code) = encode(value, class);
        (0..class as u64).all(|i| {
            let computed = select1(code, class, i) as usize;
            let expected = broadword::select1_raw(i as usize, value);
            computed == expected
        })
    }

    #[test]
    fn test_binomial_coefficient_table() {
        fn lookup(table: &mut HashMap<(u8, u8), u64>, n: u8, k: u8) -> u64 {
            if k == 0 || k == n {
                return 1;
            }
            if let Some(&v) = table.get(&(n, k)) {
                return v;
            }
            let v = lookup(table, n - 1, k - 1) + lookup(table, n - 1, k);
            table.insert((n, k), v);
            v
        }
        let mut table = HashMap::new();
        for n in 0..=64 {
            for k in 0..=n {
                assert_eq!(binomial_coefficient(n, k), lookup(&mut table, n, k));
            }
        }
    }
}

// Precomputed number of bits it takes to represent a block of 64 bits where k
// of them are set: ceil(log(binomial_coefficient(64, k))) for k in [0, 64].
// However, note that once the code length is sufficiently long (> 46), we just
// set it to 64 to hit the fast paths above.  It's not worth using a variable
// length code to save a few bits when it makes computing `rank` and `select`
// much more expensive.
pub const ENUM_CODE_LENGTH: &[u8; 65] = &[
    0, 6, 11, 16, 20, 23, 27, 30, 33, 35, 38, 40, 42, 44, 46, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 46, 44, 42, 40, 38, 35, 33, 30, 27, 23, 20, 16, 11, 6, 0,
];
